#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <map>
#include <vector>
#include <cassert>

///////////////////////////////////////////////////////////
//
// Licence : GPL
// 
// Author  : Lidong Guo
//
// E-mail  : guolidng@genomics.cn
//
///////////////////////////////////////////////////////////
//
void PrintUsage(){
std::cerr<<"\n\
 Brief   : get the hamming error rate .\n\
\n\
 Usage   : \n\
   ./CalcHD true_phased_blocks.txt merged_snps.txt \n\
\n\
    true_phased_blocks.txt is generated by PhasedSNP\n\
    merged_snps.txt is generated by MergeHapSNP\n\
";
}

struct HapSNP {
    std::string ref;
    int pos;
    std::string phase_id;
    char alt1;
    char alt2;
    void InitFromString5(const std::string & line){
        std::istringstream ist(line);
        ist>>ref>>pos>>alt1>>alt2>>phase_id;
    }

    void InitFromString4(const std::string & line){
        std::istringstream ist(line);
        ist>>ref>>pos>>alt1>>alt2;
    }
};


struct Parallel_snp {
    std::vector<std::pair<char,char>> expect;
    std::vector<std::pair<char,char>> real;

    // return wrong_number and total_number
    std::pair<int,int> hamming_score() const {
        assert(expect.size() == real.size());
        int total = expect.size();
        if( total == 0 ) return std::make_pair(0,0);
        int w1 = 0 ;
        int w2 = 0;
        // try 0:0 ,1:1
        for( int i = 0 ;i< total ; i++ ){
            if( expect.at(i).first != real.at(i).first
            || expect.at(i).second != real.at(i).second )
                w1++;
        }
        // try 0:1 ,1:0
        for( int i = 0 ;i< total ; i++ ){
            if( expect.at(i).first != real.at(i).second
            || expect.at(i).second != real.at(i).first )
                w2++;
        }
        int w = w1 < w2 ? w1 :w2 ;
        return std::make_pair(w,total);
    }

    std::pair<int,int> not_match() const {
        int total = expect.size();
        if( total == 0 ) return std::make_pair(0,0);
        int w = 0 ;
        for( int i = 0 ;i< total ; i++ ){
            if( ( expect.at(i).first == real.at(i).first &&  expect.at(i).second == real.at(i).second ) 
            || ( expect.at(i).first == real.at(i).second &&  expect.at(i).second == real.at(i).first ) )
                continue ;
            else w++;
        }
        return std::make_pair(w,total);
    }
    std::pair<int,int> switch_error() const {
        int total = expect.size()-1;
        total = 0;
        int w = 0 ;
        int prev_s = -1;
        int curr_s = -1;
        for( int i = 0 ;i< total ; i++ ){
            if( expect.at(i).first == real.at(i).first &&  expect.at(i).second == real.at(i).second ) 
                curr_s = 1;
            else if ( expect.at(i).first == real.at(i).second &&  expect.at(i).second == real.at(i).first ) 
                curr_s = 0 ;
            else continue ;
            if( prev_s == -1 ) prev_s = curr_s ;
            if( prev_s != curr_s ) 
                w += 1 ;
            prev_s = curr_s ;
            total ++ ;
        }
        return std::make_pair(w,total);
    }


    void add_snp( const HapSNP & e ,  const HapSNP & r){
        expect.push_back(std::make_pair(e.alt1,e.alt2));
        real.push_back(std::make_pair(r.alt1,r.alt2));
    }
};

std::map<std::string , std::map<int , HapSNP> > candidates_snps;
struct PhaseBlock {
    std::map<int , HapSNP> snps;

    int size() const { return snps.size() ;}

    Parallel_snp collect_candidates() const {
        Parallel_snp ret ;
        for( const auto & paired_snp : snps ) {
            const auto & snp = paired_snp.second ;
            if( candidates_snps.find(snp.ref) == candidates_snps.end()) 
                continue ;
            const auto & chrome = candidates_snps.at(snp.ref);
            if( chrome.find(snp.pos) == chrome.end()) 
                continue ;
            const auto & real = chrome.at(snp.pos);
            ret.add_snp(snp ,real);
        }
        return ret ;
    }
};

std::map<std::string , PhaseBlock> true_phased_blocks;

int main(int argc , char ** argv){
    if(argc != 3 ) {
        PrintUsage() ;
        return 0;
    }
    std::string standard(argv[1]);
    std::string target(argv[2]);
    std::ifstream ifs(standard);
    std::ifstream ift(target);
    if(!ifs.is_open()|| !ift.is_open() ) {
        std::cerr<<"open file failed !! exit ..."<<std::endl;
        return 0 ;
    }

    std::string line;
    int SNP_count = 0;
    while(!std::getline(ifs,line).eof()){
        SNP_count ++;
        HapSNP temp;
        temp.InitFromString5(line);
        (true_phased_blocks[temp.phase_id].snps)[temp.pos] = temp;
    }
    ifs.close();
    std::cerr<<"load "<<SNP_count<<" from "<<standard<<std::endl;
    SNP_count = 0;
    int HAP_SNP = 0 ;
    while(!std::getline(ift,line).eof()){
        SNP_count ++;
        HapSNP temp;
        temp.InitFromString4(line);
        if( temp.alt1 != temp.alt2 ) {
           candidates_snps[temp.ref][temp.pos] =temp;
           HAP_SNP ++ ;
        }
    }
    ift.close() ;
    std::cerr<<"load "<<SNP_count<<" from "<<target<<std::endl;
    std::cerr<<"load "<<HAP_SNP<<" in hap snp mode "<<target<<std::endl;
    int total_hit = 0;
    int total_wrong = 0 ;
    int total_pair = 0 ;
    int total_wrong_pair = 0 ;
    for( const auto & pair_block : true_phased_blocks ){
        const auto & block = pair_block.second ;
        auto snps = block.collect_candidates();
        //auto scores = snps.hamming_score();
        auto scores = snps.not_match();
        total_hit += scores.second;
        total_wrong += scores.first;
        auto scores1 = snps.switch_error() ;
        total_pair += scores1.second ;
        total_wrong_pair += scores1.first ;
    }
    std::cerr<<" total hit snps "<<total_hit<< " with wrong hit "<<total_wrong<<" score="<<float(total_wrong)/float(total_hit)<<std::endl;
    std::cerr<<" total hit snps pair "<<total_pair<< " with wrong pair "<<total_wrong_pair<<" score="<<float(total_wrong_pair)/float(total_pair)<<std::endl;
    return 0 ;
}
